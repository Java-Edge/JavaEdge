> 全是干货的技术号：
> 本文已收录在github，欢迎 star/fork：
> https://github.com/Wasabi1234/Java-Interview-Tutorial

分片就是将数据拆分到多个 Redis 实例，这样每个实例将只是所有键的一个子集。

# 1 分片有什么作用？
1. 分片可以让Redis管理更大的内存，Redis将可以使用所有机器的内存。如果没有分区，你最多只能使用一台机器的内存。
2. 分片使Redis的计算能力通过简单地增加计算机得到成倍提升,Redis的网络带宽也会随着计算机和网卡的增加而成倍增长。

# 2 分片方案
假想我们有 4 个 Redis 实例 R0，R1，R2，R3；
很多表示用户的键，像 user:1，user:2等。
有如下方案可映射键到指定 Redis 节点。

##  2.1 范围分片(range partitioning)
最简单的分片方式。通过映射对象的范围到指定的 Redis 实例来完成分片。
例如，可假设用户从 ID 0 ~ 10000 进入实例 R0，10001 ~ 20000 进入实例 R1。

这套办法行得通，并且事实上在实践中被很多人采用。

###  2.1.1 缺点
需要一个映射范围到实例的表格。该表需要管理，不同类型的对象都需要一个表，所以范围分片在 Redis 中常常并不可取，因这要比其他分片可选方案低效得多。

## 2.2 `哈希分片(hash partitioning)`
该模式适于任何键，不必是 `object_name:<id>` 形式，就像这样简单：
1. 使用一个哈希函数(例如crc32) ，将键名转为一个数字，比如93024922
2. 对该数据进行取模，将其转换为一个 0 到 3 之间数字，该数字即可映射到4个 节点之一。93024922 模 4 等于 2，所以键 foobar 应当存储到 R2

哈希分片的一种高端形式称为一致性哈希(consistent hashing)，被一些 **Redis 客户端和代理实现**。

# 3 分片的各种实现
分片可由软件栈中的不同部分来承担。

## 3.1 客户端分片
客户端直接选择正确节点来写入和读取指定键，许多 Redis 客户端实现了客户端分片。

## 3.2 代理协助分片
客户端发送请求到一个可以理解 Redis 协议的代理上，而不是直接发送到 Redis 实例。代理会根据配置好的分片模式，来保证转发我们的请求到正确的 Redis 实例，并返回响应给客户端。
Redis 和 Memcached 的代理 Twemproxy 都实现了代理协助的分片.

## 3.3 查询路由

可发送你的查询到一个随机实例，该实例会保证转发你的查询到正确节点。
Redis 集群在客户端的帮助下，实现了查询路由的一种混合形式，请求不是直接从 Redis 实例转发到另一个，而是客户端收到重定向到正确的节点。

# 4 分片的缺点
Redis 的一些特性与分片在一起时玩的不是很好：

- 涉及多个键的操作通常不支持。例如，无法直接对映射在两个不同 Redis 实例上的键执行交集
- 涉及多个键的事务不能使用
- 分片的粒度是键，所以不能使用一个很大的键来分片数据集，例如一个很大的sorted set
- 当使用了分片，数据处理变得更复杂。例如，你需要处理多个 RDB/AOF 文件，备份数据时需要聚合多个实例和主机的持久化文件
- 添加和删除容量也很复杂。例如，Redis 集群具有运行时动态添加和删除节点的能力来支持透明地再均衡数据，但是其他方式，像客户端分片和代理都不支持这个特性。但有一种称为预分片(Presharding)的技术在这一点上能帮上忙。

# 5 数据存储or缓存？
尽管无论是将 Redis 作为数据存储还是缓存，Redis 分片概念上都是一样的。
- 但作为数据存储时有个重要局限：当 Redis 作为数据存储时，一个给定的键总是映射到相同 Redis 实例。
- 当 Redis 作为缓存时，如果一个节点不可用而使用另一个节点，这并不是啥大问题，按照我们的愿望来改变键和实例的映射来改进系统的可用性(即系统响应我们查询的能力)。

一致性哈希实现常常能够在指定键的首选节点不可用时切换到其它节点。类似的，如果你添加一个新节点，部分数据就会开始被存储到这个新节点上。

主要概念：
- 如果 Redis 用作缓存，使用一致性哈希来实现伸缩扩展很容易
- 如果 Redis 用作存储，使用固定的键到节点的映射，所以节点的数量必须固定不能改变。否则，当增删节点时，就需要一个支持再平衡节点间键的系统，当前只有 Redis 集群可以做到这点。

# 6 预分片
分片存在一个问题，除非我们使用 Redis 作为缓存，否则增加和删除节点都是件麻烦事，而使用固定的键和实例映射要简单得多。

然而，数据存储的需求可能一直在变化。今天可接受 10 个 Redis 节点，但明天可能就需 50 个节点。

因为 Redis 只有相当少的内存占用且轻量级(一个空闲的实例只使用 1MB 内存)，一个简单的解决办法是一开始就开启很多实例。即使你一开始只有一台服务器，也可以在第一天就决定生活在分布式世界，使用分片来运行多个 Redis 实例在一台服务器上。
你一开始就可以选择很多数量的实例。例如，32 或者 64 个实例能满足大多数用户，并且为未来的增长提供足够的空间。
这样，当数据存储增长，需要更多 Redis 服务器，你要做的就是简单地将实例从一台服务器移动到另外一台。当你新添加了第一台服务器，你就需要把一半的 Redis 实例从第一台服务器搬到第二台，以此类推。

使用 Redis 复制，就可以在很小或者根本不需要停机的时间内完成移动数据：

1. 在新服务器上启动一个空实例
2. 移动数据，配置新实例为源实例的从服务
3. 停止客户端
4. 更新被移动实例的服务器 IP 地址配置
5. 向新服务器上的从节点发送 SLAVEOF NO ONE 命令
6. 以新的更新配置启动你的客户端
7. 最后关闭掉旧服务器上不再使用的实例

# 7 Redis分片实现
探讨完 Redis 分片理论，如何实践呢？又应该使用什么系统呢？

##  7.1 Redis 集群
Redis 集群是自动分片和高可用的首选方式。一旦 Redis 集群以及支持 Redis 集群的客户端可用，Redis 集群将会成为 Redis 分片的事实标准。

Redis 集群是查询路由和客户端分片的一种混合模式。

##  7.2 Twemproxy
Twemproxy 是 Twitter 开发的一个支持 Memcached ASCII 和 Redis 协议的代理。它是单线程的，由 C 语言编写，运行非常快，基于 Apache 2.0 许可证。

Twemproxy 支持在多个 Redis 实例间自动分片，若节点不可用，还有可选的节点排除支持。
这会改变 <键，实例> 映射，所以应该只在将 Redis 作为缓存是才使用该特性。

这并非单点故障，因为你可启动多个代理，并且让你的客户端连接到第一个接受连接的代理。

从根本上说，Twemproxy 是介于客户端和 Redis 实例之间的中间层，这就可以在最下的额外复杂性下可靠地处理我们的分片。这是当前建议的处理 Redis 分片的方式。

##  7.3 支持一致性哈希的客户端

Twemproxy 之外的可选方案，是使用实现了客户端分片的客户端，通过一致性哈希或者别的类似算法。有多个支持一致性哈希的 Redis 客户端，例如 Redis-rb 和 Predis。
查看完整的 Redis 客户端列表，看看是不是有支持你的编程语言的，并实现了一致性哈希的成熟客户端即可~

参考
- https://redis.io/topics/partitioning


![](https://img-blog.csdnimg.cn/20200825235213822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTg5NTEw,size_1,color_FFFFFF,t_70#pic_center)